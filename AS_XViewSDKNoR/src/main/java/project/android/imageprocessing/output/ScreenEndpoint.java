package project.android.imageprocessing.output;import com.cinlan.xview.utils.XviewLog;import project.android.imageprocessing.FastImageProcessingPipeline;import project.android.imageprocessing.GLRenderer;import project.android.imageprocessing.input.GLTextureOutputRenderer;/** *  一个GLRenderer的屏幕渲染扩展 *  此类接受纹理作为输入并将其呈现到屏幕上 * * @author Chris Batt */public class ScreenEndpoint extends GLRenderer implements GLTextureInputRenderer {	private int rawWidth;    private int rawHeight;	private int mode = 1;	private boolean bPreView = false;	private FastImageProcessingPipeline rendererContext;	public void SetRawSize(int width, int heigt){        rawWidth = width;        rawHeight = heigt;	}	public void setbPreView(boolean bPreView) {		this.bPreView = bPreView;	}	public void setMode(int mode) {		this.mode = mode;	}	/**	 * Creates a GLTextureToScreenRenderer. 	 * If it is not set to full screen mode, the reference to the render context is allowed to be null.	 * @param rendererContext	 * A reference to the GLSurfaceView.Renderer that contains the OpenGL context.	 *	 * Whether or not to use the input filter size as the render size or to render full screen.	 */	public ScreenEndpoint(FastImageProcessingPipeline rendererContext) {		super();		this.rendererContext = rendererContext;	}		@Override	protected void initWithGLContext() {        int prevWidth = rendererContext.getWidth();        int prevHeight = rendererContext.getHeight();		float preRate = (float)prevWidth / (float)prevHeight;		float capRate = (float)rawWidth / (float)rawHeight;		int renderWidth = prevWidth;		int renderHeight = prevHeight;		if (mode == 0) {			if (preRate >= capRate) {                renderWidth = (int) (renderHeight * capRate);				startX = (prevWidth - renderWidth) / 2;                startY = 0;			} else {				renderHeight = (int)(renderWidth/capRate);				startX = 0;				startY = (prevHeight - renderHeight) / 2;			}		} else {			if (preRate >= capRate) {				renderHeight = (int) (prevWidth / capRate);				startY = (prevHeight - renderHeight) / 2;				startX = 0;			} else {				renderWidth = (int) (prevHeight * capRate);				startX = (prevWidth - renderWidth) / 2;				startY = 0;			}		}		setRenderSize(renderWidth, renderHeight);		super.initWithGLContext();	}		/* (non-Javadoc)	 * @see project.android.imageprocessing.output.GLTextureInputRenderer#newTextureReady(int, project.android.imageprocessing.input.GLTextureOutputRenderer)	 */	@Override	public void newTextureReady(int texture, GLTextureOutputRenderer source, boolean newData) {		if(!bPreView) {			return;		}		texture_in = texture;		int w = source.getWidth();		int h = source.getHeight();		setWidth(w);		setHeight(h);		onDrawFrame();	}	public void UpdateSize(int width, int height) {		int prevWidth = width;		int prevHeight = height;		float preRate = (float)prevWidth / (float)prevHeight;		float capRate = (float)rawWidth / (float)rawHeight;		int renderWidth = prevWidth;		int renderHeight = prevHeight;		if (mode == 0) {			if (preRate >= capRate) {				renderWidth = (int) (renderHeight * capRate);				startX = (prevWidth - renderWidth) / 2;				startY = 0;			} else {				renderHeight = (int)(renderWidth/capRate);				startX = 0;				startY = (prevHeight - renderHeight) / 2;			}		} else {			if (preRate >= capRate) {				renderHeight = (int) (prevWidth / capRate);				startY = (prevHeight - renderHeight) / 2;				startX = 0;			} else {				renderWidth = (int) (prevHeight * capRate);				startX = (prevWidth - renderWidth) / 2;				startY = 0;			}		}		setRenderSize(renderWidth, renderHeight);	}}